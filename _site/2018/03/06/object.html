<html lang="en_US"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/icons/gu.png?v=qA3OXqyw77"> <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/icons/gu32x32.png?v=qA3OXqyw77"> <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/icons/gu16x16.png?v=qA3OXqyw77"> <!--[if IE]><link rel="shortcut icon" href="/assets/img/icons/favicon.ico?v=qA3OXqyw77"><![endif]--> <link rel="shortcut icon" href="/assets/img/icons/gu.ico?v=qA3OXqyw77"> <meta name="apple-mobile-web-app-title" content="Sleek"> <meta name="application-name" content="Sleek"> <meta name="theme-color" content="#ffffff"> <style class="inlineCSS"> h1{color:#313237;margin-top:0;margin-bottom:.5rem}.dark-bg{background-color:#313237}@media (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:last-of-type,.post-card:nth-child(2n+2){margin-right:0}}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}header,nav,section{display:block}h1{font-size:2em;margin:.67em 0}figure,main{display:block}figure{margin:1em 40px}a{background-color:transparent;-webkit-text-decoration-skip:objects}img{border-style:none}svg:not(:root){overflow:hidden}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}body{-webkit-overflow-scrolling:touch}*,::after,::before{-webkit-box-sizing:inherit;box-sizing:inherit}.site{display:-webkit-box;display:-ms-flexbox;display:flex;min-height:100vh;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.site__content{-webkit-box-flex:1;-ms-flex:1;flex:1}img{max-width:100%;height:auto;width:auto;vertical-align:middle}figure{margin:0}body{background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";font-size:1rem;line-height:1.5;color:#343851;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%}p{margin-top:0;margin-bottom:1.25rem}h1,h2{color:#313237;margin-top:0;margin-bottom:.5rem}a{color:#277cea;text-decoration:none}.blur{background:#fff;filter:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"><filter id="filter"><feGaussianBlur stdDeviation="16" /></filter></svg>#filter');-webkit-filter:blur(1rem);filter:blur(1rem)}.container{padding:0 20px}@media (min-width:0){.container{max-width:auto;margin:0 auto}}@media (min-width:36em){.container{max-width:540px;margin:0 auto}}@media (min-width:48em){.container{max-width:720px;margin:0 auto}}@media (min-width:62em){.container{max-width:960px;margin:0 auto}}@media (min-width:75em){.container{max-width:1170px;margin:0 auto}}.header{background-color:#fff;color:#343851;position:absolute;z-index:4;width:100%;top:0;left:0;will-change:transform;-webkit-transform:translateY(0);transform:translateY(0)}.header a{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.header__logo{display:-webkit-box;display:-ms-flexbox;display:flex;height:100%;overflow:hidden;padding:19px 0;margin-right:1.25rem;outline:0;color:#313237}.header__logo .header__logo--container{width:58px}.header__logo .header__logo--container .logo{fill:currentColor}.header__inner{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:3.75em;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.header__links{padding-bottom:.5rem;display:block;position:absolute;top:3.75em;left:0;width:100%;height:auto;visibility:hidden;background:#fff}.header__link{color:#343851;padding:1em 0;border-top:1px solid #ededed}.header__toggle{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;width:44px;height:100%;background-color:transparent;padding-left:1.25rem}.header__toggle span{display:block;position:relative;margin-top:4px;background-color:#343851;width:100%;height:2px;border-radius:1px}.header__toggle span:first-child{margin-top:0}@media (min-width:62em){.header__toggle{display:none;visibility:hidden}.header__links{position:static;display:-webkit-box;display:-ms-flexbox;display:flex;visibility:visible;width:auto;height:100%}.header__link{position:relative;padding:.938em 0;border:0}.header__link::after{content:"";display:block;position:absolute;left:0;bottom:0;height:3px;width:100%;-webkit-transform:scaleX(0);transform:scaleX(0);background:#277cea}}.post-card{display:block;width:100%;min-height:250px;border-radius:4px;overflow:hidden;background-color:#fff;-webkit-box-shadow:0 1px 3px rgba(0,0,0,.08);box-shadow:0 1px 3px rgba(0,0,0,.08);margin-bottom:5.26316%}@media (min-width:48em){.post-card{width:48.4375%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:0}}@media (min-width:75em){.post-card{width:31.25%;margin-right:3.125%}.post-card:nth-child(2n+2){margin-right:3.125%}}.post-card__thumb{margin:0;background:#fff;position:relative;overflow:hidden}.post-card__thumb::after{content:"";display:block;height:0;width:100%;padding-bottom:56.25%}.post-card__thumb>*{position:absolute;top:0;left:0;width:100%;height:100%;display:block}.post-card__inner{padding:1.875rem 1.25rem .625rem;color:#838c8d}.post-card__header{margin-bottom:.75rem}.post-card__header .post-card__meta{font-size:.875rem}.hero{margin:3.75rem auto 0;min-height:16.25rem;width:100%;position:relative;background-color:#dde5ea;background-repeat:no-repeat;background-position:50%;background-size:cover}@media (min-width:62em){.hero{margin:0 auto;height:36em}}.hero::before{position:absolute;display:block;content:"";top:0;left:0;width:100%;height:100%;background:rgba(52,56,81,.3)}.hero__wrap{position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);text-align:center;color:rgba(255,255,255,.8);max-width:40em;z-index:1}.hero__wrap .hero__title{color:#fff}.blog{background-color:#f9f9f9}.post-list{padding-top:2.5em;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}@media (min-width:48em){.hero__wrap .hero__title{font-size:2.625em;line-height:3.125rem}.post-list{padding-top:5em}} </style> <link rel="preload" href="/assets/css/main.css" as="style" onload="this.rel='stylesheet'"> <link rel="preload" href="/assets/css/post.css" as="style" onload="this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="/assets/css/main.css"></noscript> <script type="text/javascript"> /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */ (function(w){"use strict";if(!w.loadCSS){w.loadCSS=function(){}} var rp=loadCSS.relpreload={};rp.support=(function(){var ret;try{ret=w.document.createElement("link").relList.supports("preload")}catch(e){ret=!1} return function(){return ret}})();rp.bindMediaToggle=function(link){var finalMedia=link.media||"all";function enableStylesheet(){link.media=finalMedia} if(link.addEventListener){link.addEventListener("load",enableStylesheet)}else if(link.attachEvent){link.attachEvent("onload",enableStylesheet)} setTimeout(function(){link.rel="stylesheet";link.media="only x"});setTimeout(enableStylesheet,3000)};rp.poly=function(){if(rp.support()){return} var links=w.document.getElementsByTagName("link");for(var i=0;i<links.length;i++){var link=links[i];if(link.rel==="preload"&&link.getAttribute("as")==="style"&&!link.getAttribute("data-loadcss")){link.setAttribute("data-loadcss",!0);rp.bindMediaToggle(link)}}};if(!rp.support()){rp.poly();var run=w.setInterval(rp.poly,500);if(w.addEventListener){w.addEventListener("load",function(){rp.poly();w.clearInterval(run)})}else if(w.attachEvent){w.attachEvent("onload",function(){rp.poly();w.clearInterval(run)})}} if(typeof exports!=="undefined"){exports.loadCSS=loadCSS} else{w.loadCSS=loadCSS}}(typeof global!=="undefined"?global:this)) </script> </head> <body class="site"> <header class="header header-home" itemscope itemtype="http://schema.org/SiteNavigationElement" aria-label="Main navigation" > <div class="container"> <div class="header__inner"> <a class="header__logo" href="/"> <div class="header__logo--container"> <img src="/imgs/logo.png" alt="logo"> </div> </a> <nav class="header__links"> <div class="container header__links-wrapper"> <a class="header__link" href="/blog" itemprop="url"><span itemprop="name">Home</span></a> <a class="header__link" href="/about" itemprop="url"><span itemprop="name">About</span></a> <a class="header__link" href="/contact" itemprop="url"> <span itemprop="name">Contact</span> </a> </div> </nav> <div class="header__toggle"> <span></span> <span></span> <span></span> </div> </div> </div> </header> <!-- <div class="hero"> </div> --> <main class="site__content post-site"> <div class="container post-con"> <p class="title-post">面向对象</p> <p class="author-post"> 发表于 <span class="post-card__meta"> <time>2018-03-06</time> </span> by <span class="author">guyuqing</span> </p> <article class="post-content" itemprop="articleBody"> <h2 id="1对象的定义"><strong>1.</strong>对象的定义</h2> <p><code class="highlighter-rouge">在ECMAScript-262中，对象被定义为“无序属性的集合，其属性可以包含基本值，对象或者函数”。也就是说，在JavaScript中，对象无非就是由一些列无序的key-value对组成。其中value可以是基本值，对象或者函数。</code></p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 这里的person就是一个对象
  var person = {
      name: 'Tom',
      age: 18,
      getName: function() {},
      parent: {}
  }
</code></pre></div></div> <h3 id="创建对象">创建对象</h3> <p>我们可以通过new的方式创建一个对象。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var obj = new Object();
</code></pre></div></div> <p>也可以通过对象字面量的形式创建一个简单的对象。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var obj = {};
</code></pre></div></div> <p>当我们想要给我们创建的简单对象添加方法时，可以这样表示。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // 可以这样
  var person = {};
  person.name = "TOM";
  person.getName = function() {
        return this.name;
  }

  // 也可以这样
  var person = {
      name: "TOM",
      getName: function() {
          return this.name;
      }
  }
</code></pre></div></div> <h3 id="访问对象的属性和方法">访问对象的属性和方法</h3> <p>假如我们有一个简单的对象如下：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var person = {
      name: 'TOM',
      age: '20',
      getName: function() {
          return this.name
      }
  }
</code></pre></div></div> <p>当我们想要访问他的name属性时，可以用如下两种方式访问。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  person.name
  // 或
  person['name']
</code></pre></div></div> <p>如果我们想要访问的属性名是一个变量时，常常会使用第二种方式。例如我们要同时访问<code class="highlighter-rouge">person</code>的<code class="highlighter-rouge">name</code>与<code class="highlighter-rouge">age</code>，可以这样写：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ['name', 'age'].forEach(function(item) {
      console.log(person[item]);
  })
</code></pre></div></div> <h2 id="2工厂模式"><strong>2.</strong>工厂模式</h2> <p>使用上面的方式创建对象很简单，但是在很多时候并不能满足我们的需求。就以person对象为例。假如我们在实际开发中，不仅仅需要一个名字叫做TOM的person对象，同时还需要另外一个名为Jake的person对象，虽然他们有很多相似之处，但是我们不得不重复写两次。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var perTom = {
      name: 'TOM',
      age: 20,
      getName: function() {
          return this.name
      }
  };

  var perJake = {
      name: 'Jake',
      age: 22,
      getName: function() {
          return this.name
      }
  }
</code></pre></div></div> <p>我们可以使用工厂模式的方式解决这个问题。顾名思义，工厂模式就是我们提供一个模子，然后通过这个模子复制出我们需要的对象。我们需要多少个，就复制多少个。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var createPerson = function (name, age) {
  // 声明一个对象，该对象就是工厂模式的模子
  var o = new Object();
      // 依次添加我们需要的属性和方法
      o.name = name;
      o.age = age;
      o.getName = function () {
          return this.name;
      }
      return o;
  }
  // 创建两个实例
  var perTom = createPerson('TOM', 20);
  var perJake = createPerson('Jake', 20);
</code></pre></div></div> <p>相信上面的代码并不难理解，也不用把工厂模式看得太过高大上。很显然，工厂模式帮助我们解决了重复代码上的麻烦，让我们可以写很少的代码，就能够创建很多个person对象。但是这里还有两个麻烦，需要我们注意。 这种方法的问题是，perTom和perJake之间没有内在的联系，不能反映出它们是同一个原型对象的实例。 第一个麻烦就是这样处理，我们没有办法识别对象实例的类型。使用instanceof可以识别对象的类型，如下例子：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var obj = {};
var foo = function() {}

console.log(obj instanceof Object);  // true
console.log(foo instanceof Function); // true
</code></pre></div></div> <p>因此在工厂模式的基础上，我们需要使用构造函数的方式来解决这个麻烦。</p> <h2 id="3构造函数"><strong>3.</strong>构造函数</h2> <p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。</p> <p>比如，猫的原型对象现在可以这样写，</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Cat(name,color){

        this.name=name;

        this.color=color;

    }
</code></pre></div></div> <p>我们现在就可以生成实例对象了。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var cat1 = new Cat("大毛","黄色");

    var cat2 = new Cat("二毛","黑色");

    alert(cat1.name); // 大毛

    alert(cat1.color); // 黄色
</code></pre></div></div> <p>这时cat1和cat2会自动含有一个constructor属性，指向它们的构造函数。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alert(cat1.constructor == Cat); //true

    alert(cat2.constructor == Cat); //true
</code></pre></div></div> <p>Javascript还提供了一个instanceof运算符，验证原型对象与实例对象之间的关系。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alert(cat1 instanceof Cat); //true

    alert(cat2 instanceof Cat); //true
</code></pre></div></div> <p>构造函数方法很好用，但是存在一个浪费内存的问题。</p> <p>请看，我们现在为Cat对象添加一个不变的属性type（种类），再添加一个方法eat（吃）。那么，原型对象Cat就变成了下面这样：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Cat(name,color){

        this.name = name;

        this.color = color;

        this.type = "猫科动物";

        this.eat = function(){
            alert("吃老鼠");
        };
        
    }
</code></pre></div></div> <p>还是采用同样的方法，生成实例：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var cat1 = new Cat("大毛","黄色");

    var cat2 = new Cat ("二毛","黑色");

    alert(cat1.type); // 猫科动物

    cat1.eat(); // 吃老鼠
</code></pre></div></div> <p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type属性和eat()方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。 能不能让type属性和eat()方法在内存中只生成一次，然后所有实例都指向那个内存地址呢？回答是可以的。</p> <h2 id="4prototype模式原型模式"><strong>4.</strong>Prototype模式（原型模式）</h2> <p><code class="highlighter-rouge">Javascript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</code></p> <p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code class="highlighter-rouge">prototype</code>对象上。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Cat(name, color) {

        this.name = name;

        this.color = color;

    }

    Cat.prototype.type = "猫科动物";

    Cat.prototype.eat = function () {

        alert("吃老鼠");

    }    
</code></pre></div></div> <p>然后，生成实例。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var cat1 = new Cat("大黑", "黑色");

    var cat1 = new Cat("大黄", "黄色");

</code></pre></div></div> <p>这是所有实例的<code class="highlighter-rouge">type</code>属性和<code class="highlighter-rouge">eat()</code>方法，其实都是同一个内存地址，指向<code class="highlighter-rouge">prototype</code>对象，因此提高了运行效率。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alert(cat1.eat == cat2.eat); //true
</code></pre></div></div> <h2 id="5构造函数的继承"><strong>5.</strong>构造函数的继承</h2> <p>现在有一个“动物”对象的构造函数。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Animal (){
        this.species = "动物";
    }
</code></pre></div></div> <p>还有一个“猫”对象的构造函数。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Cat(name, color) {
        this.name = name;
        this.color = color;
    }
</code></pre></div></div> <p>怎样使“猫”继承“动物”呢？</p> <h3 id="1构造函数绑定"><strong>（1）</strong>构造函数绑定</h3> <p>第一种方法就是使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Cat(name,color){
        Animal.apply(this, arguments); // arguments指参数数组[name,color]
        this.name = name;
        this.color = color;
    }
    var cat1 = new Cat("大黑", "黑色")；
    console.log(cat1.species); //动物
</code></pre></div></div> <h3 id="2prototype模式"><strong>（2）</strong>prototype模式</h3> <p>第二种方法更常见，使用prototype属性。</p> <p>Javascript规定，每一个构造函数都有一个<code class="highlighter-rouge">prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p> <p>如果“猫”的<code class="highlighter-rouge">prototype</code>对象，指向一个Animal的实例，那么所有“猫”的实例，就能继承Animal了。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Cat.prototype = new Animal();

    Cat.prototype.constructor = Cat;

    var cat1 = new Cat("大黑", "黑色");

    console.log(cat1.species); //动物

</code></pre></div></div> <p>代码的第一行，我们将Cat的<code class="highlighter-rouge">prototype</code>对象指向一个Animal的实例。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Cat.prototype = new Animal();
</code></pre></div></div> <p>相当于完全删除了<code class="highlighter-rouge">prototype</code>对象原先的值，然后赋予一个新值。 但是在这一行之前<code class="highlighter-rouge">Cat.prototype.constructor</code>是指向<code class="highlighter-rouge">Cat</code>的，加了这一行后，<code class="highlighter-rouge">Cat.prototype.constructor</code>指向了<code class="highlighter-rouge">Animal</code>。 由于每一个实例也有一个<code class="highlighter-rouge">constructor</code>属性，默认调用<code class="highlighter-rouge">prototype</code>对象的<code class="highlighter-rouge">constructor</code>属性。 这会导致构造函数<code class="highlighter-rouge">Cat</code>生成实例的<code class="highlighter-rouge">constructor</code>却指向了<code class="highlighter-rouge">Animal</code>,从而造成继承链的紊乱。</p> <p>所以第二行就是将<code class="highlighter-rouge">Cat.prototype.constructor</code>改回指向<code class="highlighter-rouge">Cat</code>。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Cat.prototype.constructor = Cat;
</code></pre></div></div> <p>所以在编程中，如果替换了<code class="highlighter-rouge">prototype</code>对象，必须为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p> <h3 id="3直接继承prototype"><strong>（3）</strong>直接继承prototype</h3> <p>第三种方法是对第二种方法的改进。由于<code class="highlighter-rouge">Animal</code>对象中，不变的属性都可以直接写入<code class="highlighter-rouge">Animal.protype</code>。所以，我们也可以让<code class="highlighter-rouge">Cat()</code>跳过<code class="highlighter-rouge">Animal()</code>，直接继承<code class="highlighter-rouge">Animal.prototype</code>。</p> <p>现在，我们将<code class="highlighter-rouge">Animal</code>对象改写：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Animal (){ }

    Animal.prototype.species = "动物"；
</code></pre></div></div> <p>然后，将Cat的<code class="highlighter-rouge">prototype</code>对象，然后指向<code class="highlighter-rouge">Animal</code>的<code class="highlighter-rouge">prototype</code>对象，这样就完成了继承。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Cat.prototype = Animal.prototype;

    Cat.prototype.constructor = Cat;

    var cat1 = new Cat("大黄","黄色");

    alert(cat1.species); // 动物
</code></pre></div></div> <p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立Animal的实例了），比较省内存。缺点是Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会影响到Animal.prototype。</p> <p>所以，上面的代码是有问题的。第二行</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Cat.prototype.constructor = Cat;
</code></pre></div></div> <p>这一句实际上把Animal.prototype对象的属性也改掉了</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alert(Animal.prototype.constructor); // Cat
</code></pre></div></div> <h3 id="4利用空对象作为中介"><strong>（4）</strong>利用空对象作为中介</h3> <p>由于直接继承prototype存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var F = function (){};
    F.prototype = Animal.prototype;
    Cat.prototype = new F();
    Cat.prototype.constructor = Cat;
</code></pre></div></div> <p>F是空对象，所以几乎不占内存。这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    alert(Animal.prototype.constructor); //Animal
</code></pre></div></div> <p>我们将上面的方法，封装成一个函数，便于使用。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function extend(Child, Parent) {
        var F = function() {};
        F.prototype = Parent.prototype;
        Child.prototype = new F();
        Child.prototype.constructor = Clild;
        Child.uber = Parent.prototype;
        &lt;!-- 这里的意思是为子对象设置一个uber属性，直接指向父对象的prototype属性。这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质 --&gt;
    }
</code></pre></div></div> <p>使用的时候</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    extend(Cat, Animal);
    var cat1 = new Cat("大黑", "黑色");
    console.log(cat1.species); // 动物
</code></pre></div></div> <h3 id="5拷贝继承"><strong>（5）</strong>拷贝继承</h3> <p>上面采用prototype对象，实现继承。我们换一种思路，纯粹采用“拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷进子对象，不也能实现继承吗？这样我们就有了第五种方法。</p> <p>首先，还是把<code class="highlighter-rouge">Animal</code>的所有不变属性，都放到它的prototype对象上。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function Animal(){}
    Animal.prototype.species = "动物"；
</code></pre></div></div> <p>然后，再写一个函数，实现属性拷贝的目的。</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    function extend2(Child, Parent){
        var p = Parent.prototype;
        var c = Child.prototype;
        for(var i in p) {
            c[i] = p[i];
        }
        c.uber = p;
    }
</code></pre></div></div> <p>这个函数的作用，就是将父对象的<code class="highlighter-rouge">prototype</code>对象中的属性，一一拷贝给<code class="highlighter-rouge">Child</code>对象的<code class="highlighter-rouge">prototype</code>对象。 使用的时候</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    extend2(Cat, Animal);
    var cat1 = new Cat("大黑", "黑色");
    console.log(cat1.species); // 动物
</code></pre></div></div> </article> <div class="post-content controls__inner"> <div class="controls__item prev"> <span>Previous</span> <a href="/2018/03/05/es6.html"> <span> <svg xmlns="http://www.w3.org/2000/svg" width="6" height="11"> <path fill="fillColor" d="M5.647 1.718c.37-.434.323-1.09-.106-1.465A1.016 1.016 0 0 0 4.095.36L.25 4.875a1.05 1.05 0 0 0 .017 1.378l3.95 4.407c.38.424 1.03.456 1.448.07a1.05 1.05 0 0 0 .07-1.468l-3.34-3.725 3.253-3.819z"/> </svg> </span> ECMAScript 6 入门 </a> </div> <div class="controls__item next"> </div> </div> </div> </main> <footer class="footer"> <div class="container"> <nav class="social"> <a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/GuyYQ"> <svg class="social__icon" viewBox="0 0 20 20" width="20px" height="20px"><path d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg> </a> </nav> <span>&copy; 2018 . All rights reserved.</span> </div> </footer> <script async src="/assets/js/bundle.js"></script> </body> </html>
